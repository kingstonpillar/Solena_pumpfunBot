import fetch from "node-fetch";import { BI, biPct } from "./bigintSafe.js";const HELIUS_RPC_URL =  "https://mainnet.helius-rpc.com/?api-key=ffce4942-e7c6-45cc-ab51-1e0ce95bb175";const DEBUG = String(process.env.DEBUG || "0") === "1";// Rate controlconst HELIUS_MIN_INTERVAL_MS = Number(process.env.HELIUS_MIN_INTERVAL_MS || 250);const LOG_EVERY_MS = Number(process.env.HELIUS_LOG_EVERY_MS || 60_000);// Optional cachingconst SUPPLY_CACHE_TTL_MS = Number(process.env.SUPPLY_CACHE_TTL_MS || 5_000);const TOP_CACHE_TTL_MS = Number(process.env.TOP_CACHE_TTL_MS || 5_000);const RAW_SUPPLY_CACHE_TTL_MS = Number(process.env.RAW_SUPPLY_CACHE_TTL_MS || 5_000);let _lastRpcAt = 0;async function rpcThrottle() {  const now = Date.now();  const wait = _lastRpcAt + HELIUS_MIN_INTERVAL_MS - now;  if (wait > 0) await new Promise((r) => setTimeout(r, wait));  _lastRpcAt = Date.now();}// log throttle by keyconst _logLast = new Map();function debugLog(key, ...args) {  if (!DEBUG) return;  const now = Date.now();  const last = _logLast.get(key) || 0;  if (now - last < LOG_EVERY_MS) return;  _logLast.set(key, now);  console.log(...args);}// simple cacheconst _cache = new Map();function cacheGet(key) {  const v = _cache.get(key);  if (!v) return null;  if (Date.now() > v.exp) {    _cache.delete(key);    return null;  }  return v.val;}function cacheSet(key, val, ttlMs) {  _cache.set(key, { val, exp: Date.now() + ttlMs });  return val;}// Unified RPC helper (this is what was missing in your paste)async function heliusRpc(method, params, { debugKey = "", debugLabel = "" } = {}) {  await rpcThrottle();  const resp = await fetch(HELIUS_RPC_URL, {    method: "POST",    headers: { "Content-Type": "application/json" },    body: JSON.stringify({      jsonrpc: "2.0",      id: 1,      method,      params,    }),  });  const json = await resp.json();  if (debugKey) debugLog(debugKey, "[heliusTop10]", debugLabel || method, json);  if (json?.error) {    debugLog(      `err:${method}:${params?.[0] || ""}`,      "[heliusTop10][ERR]",      method,      params?.[0] || "",      json.error?.message    );    return null;  }  return json;}// Function to fetch top 10 token holders from Heliusexport async function getTop10FromHelius(mintAddress) {  const cacheKey = `top10:${mintAddress}`;  const cached = cacheGet(cacheKey);  if (cached) return cached;  const json = await heliusRpc("getTokenLargestAccounts", [mintAddress], {    debugKey: `top10_resp:${mintAddress}`,    debugLabel: "getTokenLargestAccounts",  });  if (!json) return null;  return cacheSet(cacheKey, json?.result || null, TOP_CACHE_TTL_MS);}// Function to fetch the token supply (uiAmount + decimals)export async function getTokenSupplyFromHelius(mintAddress) {  const cacheKey = `supply_ui:${mintAddress}`;  const cached = cacheGet(cacheKey);  if (cached) return cached;  const json = await heliusRpc("getTokenSupply", [mintAddress], {    debugKey: `supply_ui_resp:${mintAddress}`,    debugLabel: "getTokenSupply(ui)",  });  if (!json) return null;  const totalSupply = json?.result?.value?.uiAmount || 0;  const decimals = json?.result?.value?.decimals || 0;  return cacheSet(cacheKey, { totalSupply, decimals }, SUPPLY_CACHE_TTL_MS);}// RAW supply helper (base units string -> BigInt)async function getTokenSupplyRawBI(mintAddress) {  const cacheKey = `supply_raw:${mintAddress}`;  const cached = cacheGet(cacheKey);  if (cached) return cached;  const json = await heliusRpc("getTokenSupply", [mintAddress], {    debugKey: `supply_raw_resp:${mintAddress}`,    debugLabel: "getTokenSupply(raw)",  });  if (!json) return null;  const totalRawStr = json?.result?.value?.amount;  if (!totalRawStr) return null;  return cacheSet(cacheKey, BI(totalRawStr), RAW_SUPPLY_CACHE_TTL_MS);}// ✅ Top 10 percentage (RAW base-units math, throttled)export async function Top10PCT(mintAddress) {  try {    // keep your call (still useful for decimals/ui, now throttled + log-gated)    const sup = await getTokenSupplyFromHelius(mintAddress);    if (!sup) return null;    const totalSupplyRawBI = await getTokenSupplyRawBI(mintAddress);    if (!totalSupplyRawBI) return null;    const top10Data = await getTop10FromHelius(mintAddress);    const arr = Array.isArray(top10Data?.value) ? top10Data.value : [];    if (!arr.length) return null;    let sumTop10RawBI = 0n;    for (const holder of arr.slice(0, 10)) {      const rawStr = holder?.amount != null ? String(holder.amount) : "0";      sumTop10RawBI += BI(rawStr);    }    const pctStr = biPct(sumTop10RawBI, totalSupplyRawBI);    const pctNum = Number(pctStr);    if (!Number.isFinite(pctNum)) return null;    return Math.max(0, Math.min(100, pctNum));  } catch (err) {    console.error("Error while calculating top 10 percentage:", err);    return null;  }}// ✅ Top 1 percentage (RAW base-units math, throttled)export async function Top1pct(mintAddress) {  try {    // keep your call path (now throttled + log-gated)    const sup = await getTokenSupplyFromHelius(mintAddress);    if (!sup) return 0;    const totalSupplyRawBI = await getTokenSupplyRawBI(mintAddress);    if (!totalSupplyRawBI) return 0;    const topData = await getTop10FromHelius(mintAddress);    const arr = Array.isArray(topData?.value) ? topData.value : [];    if (!arr.length) return 0;    const top1 = arr[0];    const top1RawStr = top1?.amount != null ? String(top1.amount) : "0";    const top1RawBI = BI(top1RawStr);    const pctStr = biPct(top1RawBI, totalSupplyRawBI);    const pctNum = Number(pctStr);    if (!Number.isFinite(pctNum)) return 0;    return Math.max(0, Math.min(100, pctNum));  } catch (e) {    console.error("[Top1pct] error:", e?.message || e);    return 0;  }}